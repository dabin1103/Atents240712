에셋 사이트 kenney

게임 알고리즘

좌표계

데카르트 좌표계

왼손좌표계(window)
오른손좌표계(일반수학, OpenGL, 3D Max)

로컬 좌표계 : 특정 물체를 기준으로 한 좌표계
월드 좌표계 : 월드(맵)의 특정 위치를 기준으로 한 좌표계

스크린 좌표계 : 디스플레이의 위치를 표현하기 위한 좌표계

렌더링 파이프라인
 - 모델 생성(로컬좌표결정)
 - 월드 배치(월드 변환, World Transform)
 - 카메라의 위치와 방향에 따라 변환(카메라 변환)
 - 투영 변환(Projection Transform)
 - 레스터화(Rasterization)

벡터(Vector)
 - 힘의 크기(Scalar)와 방향을 나타내는 것
 - (x,y,z)
 - 단위벡터(Unit Vector) : 크기가 1인 벡터, 방향만 표현하는 벡터
 - 정규화(Normalize) : 벡터를 단위벡터로 만드는 작업
 - 벡터의 크기 = Root(X^2+Y^2+Z^2)
 - 벡터와 벡터의 더하기 = (1,2,3) + (3,6,9) = (4,8,12)
 - 벡터와 벡터의 빼기 = (1,2,3) - (3,6,9) = (-2, -4, -6)
 - 벡터와 스칼라의 곱하기 = (1,2,3) * 5 = (5, 10, 15)
 - 벡터와 스칼라의 나누기 = (1,2,3) / 5 = (0.2, 0.4, 0.6)
 - 벡터와 벡터의 곱하기 : 외적(Cross Product)과 내적(Dot Product)으로 구분됨
   내적 : 각 항목끼리 곱한 후에 더한 결과, 내적의 결과는 스칼라가 나온다.
   외적 : a x b = (a2b3-a3b2, a3b1-a1b3, a1b2-a2b1)
    - 결과 : 두 벡터가 만드는 평면에 수직한 벡터(Normal Vector)를 구한다.
    - 삼각형의 앞면과 뒷면을 구분할 수 있게 된다.

방향 벡터
 - 특정 위치에서 특정 위치로 가는 벡터
 - 공식 : 도착 위치 - 출발 위치

행렬(Matrix)
 - 숫자를 행과 열로 나열해 놓은 것
 - 직사각형의 형태를 띄어야 한다.
 - 단위 행렬(숫자1과 같은 특성을 가진다)
 - 역행렬(행렬A와 A의 역행렬을 곱하면 단위행렬이 된다.)
 - Transform을 저장한다.

쿼터니언(사원수, Quaternion)
 - 숫자 4개로 회전을 표현한다.
 - 오일러 앵글에서 발생하는 짐벌락 현상을 방지할 수 있다.
 - 행렬에 비해 더 빠르게 계산이 가능하다.

연산자(Operator)
 - 산술 연산자
 - 대입 연산자
 - 비교 연산자
 - 논리 연산자
 - 비트 연산자 : &(and), |(or), <<(left shift), >>(right shift)
	0101 & 1100 = 0100
	0101 | 1100 = 1101
	0010 0011 << 2 = 1000 1100
	1000 1000 << 1
	8bit 크기인 경우 : 0001 0000
	16bit 크기인 경우 : 0000 0001 0001 0000
	0010 0011 >> 2 = 0000 1000

정점(Vertex) : 3D 모델을 구성하는 점
엣지(Edge) : 정점을 연결한 선
페이스(Face) : 폴리곤. 정점과 엣지를 이용해 만든 면
메시(Mesh) : 페이스를 모아 만든 오브젝트의 형태

보간(Interpolation) : 시작값과 종료값이 있을 때 진행 정도에 따라 사이값을 계산하는 방식

키프레임 애니메이션

값형식(Value type)
 - struct 상속 받음
 - stack 메모리 사용
 - 깊은 복사(완전한 사본을 만드는 복사)

참조형식(Reference type)
 - class 상속 받음
 - heap 메모리 사용
 - 얕은 복사(주소만 복사)

자료구조(Data Structure)
 - 데이터를 어떻게 저장할지를 나타내는 방식


		선형 자료구조(Linear Data Structure)

배열
 - 장점 : 랜덤 엑세스 속도가 빠르다.
 - 단점 : 사이즈가 고정이다. 중간 삽입 삭제가 힘들다.

리스트(List)
 - 장점 : 삽입 삭제가 빠르다.
 - 단점 : 랜덤 엑세스 속도가 리스트 길이에 비례한다.
 - 용어
    Node : 데이터 하나
    Head : 첫번째 노드
    Tail : 마지막 노드

스택(Stack)
 - LIFO(Last In First Out)
 - 용어
    Top : 스택의 제일 윗부분
    Push : 스택의 Top에 데이터를 추가한다.
    Pop : 스택의 Top에서 데이터를 꺼낸다.

큐(Queue)
 - FIFO(First In First Out)
 - 용어
    Front : 큐의 제일 앞부분
    Rear : 큐의 제일 뒷부분
    Enqueue : 큐의 Rear에 데이터 추가
    Dequeue : 큐의 Front에서 데이터를 꺼냄


		비선형
트리(Tree)
 - 계층 구조를 가진다
 - 1:N 구조
    - 부모는 여러개의 자식을 가질 수 있다.
    - 자식은 하나의 부모만 가진다.

이진 탐색 트리(Binary Search Tree)
 - 모든 노드는 최대 2개의 자식을 가질 수 있다.
 - 노드가 유니크한 키값을 가진다.
 - 키값은 반드시 순서가 있는 값이다.
 - 두 노드를 비교했을 때 키값이 작으면 왼쪽 크면 오른쪽에 노드가 있어야 한다.

Heap(힙)
 - Min Heap과 Max Heap이 있음
 - 부모가 자식보다 크면 Max Heap
 - 부모가 자식보다 작으면 Min Heap
 - 완전 이진트리의 형태를 지닌다.